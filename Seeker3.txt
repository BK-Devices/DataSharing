ðŸ”¹ COMMON TIMEOUT SUPPORT (ADD ONCE)
#include <atomic>
#include <chrono>
#include <unistd.h>

static std::chrono::steady_clock::time_point EO_LastIOTime;
static std::chrono::steady_clock::time_point IR_LastIOTime;

static const int EO_TIMEOUT_MS = 3000;
static const int IR_TIMEOUT_MS = 3000;

ðŸ”¹ INTERRUPT CALLBACKS (EO + IR)
static int EOInterruptCallback(void *ctx)
{
    auto now = std::chrono::steady_clock::now();
    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(now - EO_LastIOTime).count();
    return (diff > EO_TIMEOUT_MS) ? 1 : 0;
}

static int IRInterruptCallback(void *ctx)
{
    auto now = std::chrono::steady_clock::now();
    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(now - IR_LastIOTime).count();
    return (diff > IR_TIMEOUT_MS) ? 1 : 0;
}

ðŸ”¹ initEOStream() (NON-BLOCKING + TIMEOUT)
bool Seeker::initEOStream(void)
{
    avformat_network_init();

    EO_pFormatCtx = avformat_alloc_context();
    EO_pFormatCtx->interrupt_callback.callback = EOInterruptCallback;
    EO_pFormatCtx->interrupt_callback.opaque = NULL;

    EO_LastIOTime = std::chrono::steady_clock::now();

    EO_avdic = NULL;

    if (EO_VideoSrc.find("rtsp://") == 0)
    {
        av_dict_set(&EO_avdic, "rtsp_transport", "tcp", 0);
        av_dict_set(&EO_avdic, "stimeout", "3000000", 0);
        av_dict_set(&EO_avdic, "rw_timeout", "3000000", 0);
    }

    if (avformat_open_input(&EO_pFormatCtx, EO_VideoSrc.c_str(), NULL, &EO_avdic) != 0)
        return false;

    if (avformat_find_stream_info(EO_pFormatCtx, NULL) < 0)
        return false;

    EO_videoStream = -1;
    for (unsigned int i = 0; i < EO_pFormatCtx->nb_streams; i++)
    {
        if (EO_pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
        {
            EO_videoStream = i;
            break;
        }
    }

    if (EO_videoStream == -1)
        return false;

    EO_pCodecCtx = avcodec_alloc_context3(NULL);
    avcodec_parameters_to_context(
        EO_pCodecCtx,
        EO_pFormatCtx->streams[EO_videoStream]->codecpar);

    EO_pCodec = avcodec_find_decoder(EO_pCodecCtx->codec_id);
    if (!EO_pCodec)
        return false;

    if (avcodec_open2(EO_pCodecCtx, EO_pCodec, NULL) < 0)
        return false;

    EO_pFrame = av_frame_alloc();
    EO_pFrameEO = av_frame_alloc();

    EO_img_convert_ctx = sws_getContext(
        EO_pCodecCtx->width,
        EO_pCodecCtx->height,
        EO_pCodecCtx->pix_fmt,
        EO_pCodecCtx->width,
        EO_pCodecCtx->height,
        AV_PIX_FMT_BGR24,
        SWS_BICUBIC,
        NULL, NULL, NULL);

    EO_numBytes = av_image_get_buffer_size(
        AV_PIX_FMT_BGR24,
        EO_pCodecCtx->width,
        EO_pCodecCtx->height,
        1);

    EO_out_buffer = (uint8_t *)av_malloc(EO_numBytes);
    av_image_fill_arrays(
        EO_pFrameEO->data,
        EO_pFrameEO->linesize,
        EO_out_buffer,
        AV_PIX_FMT_BGR24,
        EO_pCodecCtx->width,
        EO_pCodecCtx->height,
        1);

    EO_packet = av_packet_alloc();

    return true;
}

ðŸ”¹ readEOFrames() (NO DELAY FOR LIVE SOURCES)
void Seeker::readEOFrames(void)
{
    Mat VideoFrame;
    VideoFrame.create(
        EO_pCodecCtx->height,
        EO_pCodecCtx->width,
        CV_8UC3);

    while (EOVideoReadFlag)
    {
        EO_LastIOTime = std::chrono::steady_clock::now();

        int ret = av_read_frame(EO_pFormatCtx, EO_packet);

        if (ret == AVERROR_EXIT || ret < 0)
        {
            usleep(100 * 1000); // Prevent spin
            continue;
        }

        if (EO_packet->stream_index == EO_videoStream)
        {
            if (avcodec_send_packet(EO_pCodecCtx, EO_packet) == 0 &&
                avcodec_receive_frame(EO_pCodecCtx, EO_pFrame) == 0)
            {
                sws_scale(
                    EO_img_convert_ctx,
                    EO_pFrame->data,
                    EO_pFrame->linesize,
                    0,
                    EO_pCodecCtx->height,
                    EO_pFrameEO->data,
                    EO_pFrameEO->linesize);

                memcpy(
                    VideoFrame.data,
                    EO_pFrameEO->data[0],
                    EO_pCodecCtx->height * EO_pFrameEO->linesize[0]);

                if (AI_Type == 2)
                {
                    CameraData.VideoFrame = VideoFrame;
                    CameraData.VideoType = AI_Type;
                    CameraData.FrameTime = steady_clock::now();
                    CameraData.FrameFlag = true;
                }
            }
        }

        av_packet_unref(EO_packet);

        /* ---------- SLEEP ONLY FOR FILE ---------- */
        if (!(EO_VideoSrc.find("/dev/video") == 0 ||
              EO_VideoSrc.find("rtsp://") == 0 ||
              EO_VideoSrc.find("http://") == 0 ||
              EO_VideoSrc.find("https://") == 0))
        {
            usleep(FrameDelay * 1000);
        }
    }
}

ðŸ”¹ IR IMPLEMENTATION (EO â†’ IR REPLACEMENT)
âœ… initIRStream()

(Identical logic, only names changed)

IR_pFormatCtx->interrupt_callback.callback = IRInterruptCallback;
IR_LastIOTime = std::chrono::steady_clock::now();

âœ… readIRFrames()
IR_LastIOTime = std::chrono::steady_clock::now();

/* same logic as EO */

if (!(IR_VideoSrc.find("/dev/video") == 0 ||
      IR_VideoSrc.find("rtsp://") == 0 ||
      IR_VideoSrc.find("http://") == 0 ||
      IR_VideoSrc.find("https://") == 0))
{
    usleep(FrameDelay * 1000);
}





